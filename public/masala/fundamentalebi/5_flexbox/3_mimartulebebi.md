# მიმართულებები

## შესავალი

ახლა ვისწავლით, როგორ მივცეთ ორიენტაია ელემენტებს, რომლებიც ფლექს კონტეინერის შიგნით არიან და როგორ ვაკონტროლოთ ისინი `flex-direction`-ის გამოყენებით.

## გაკვეთილის მიმოხილვა

- ისწავლით ფლექს კონტეინერის "მიმართულებებს".
- ისწავლით როგორ შეცვალოთ ეს მიმართულებები.

ფლექსბოქსს შეუძლია იმუშაოს როგორც ჰორიზონტალურად, ისე ვერტიკალურად და ეს მხოლოდ რამდენიმე სტილის მინიჭებით შეგვიძლია.

ჩვეულებრივ, ფლექს კონტეინერში განთავსებული კონტენტის თანმიმდევრობა არის ჰორიზონტალური, ანუ `row`, მაგრამ შეგიძლიათ გახადოთ ვერტიკალური, ანუ დაადოთ `column` მნიშვნელობა. მიმართულება CSS-თი ასე განისაზღვრება:

```css
.flex-container {
  flex-direction: column;
}
```

## მიმართულებები

არ აქვს მნიშვნელობა რომელ მიმართულებას იყენებთ, თქვენ უნდა იფიქროთ თქვენს flex-container-ზე, რომელსაც აქვს ორი მიმართულება: ვერტიკალური და ჰორიზონტალური. ამ მიმართულებების შეცვლა `flex-direction`-ის მნიშვნელობის შცვლით შეგვიძლია. ძირითად შემთხვევებში, `flex-direction: row` აყენებს კონტენტს ჰორიზონტალურად (მარცხნიდან-მარჯვნივ) და `column` აყენებს კონტენტს ვერტიკალურად (ზევიდან ქვევით).

მაგალითით რომ ვიმსჯელოთ, ჩვენ ვადებთ `display: flex`-ს დივს და ის თავის შიგნით მყოფ ელემენტებს (შვილებს) აყენებს ჰორიზონტალურად, ანუ `display: flex`-ს ის გაწერის დროს ავტომატურად ედება `flex-direction: row`. ქვედა მაგალითი მსგავსია. თუ თქვენ წაუშლით კომენტარის თეგს `flex-direction: column` ეს დივები დაეწყობა ერთმანეთის თავზე (ვერტიკალურად).

<iframe height="300" style="width: 100%;" scrolling="no" title="flex-direction example" src="https://codepen.io/xazy/embed/abMJYWe?default-tab=html%2Cresult&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/xazy/pen/abMJYWe">
  flex-direction example</a> by XazyProject (<a href="https://codepen.io/xazy">@xazy</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

ერთი რამ, რაც გასათვალისწინებელია ამ მაგალითში: როდესაც `flex-direction: column`-ს დავადებთ, ისე არ იმუშავებს, როგორც წარმოგვიდგენია, თუ მასთან ერთად გამოვიყენებთ `flex: 1` სტილს. გადააკეთეთ `flex: 1 1 auto` სტილი უბრალოდ `flex: 1`-ად და დააკვირდით რა მოუვა ჩვენს დივებს. ისინი განადგურდებიან, მიუხედავად იმისა, რომ `height`(სიმაღლე) მითითებულია.

ასე ხდება, რადგან, როგორც ვიცით, უბრალოდ `flex: 1` ხდის `flex-basis`-ის მნიშვნელობას `0`-ს, რაც გულისხმობს ყველა გაზრდა(`flex-grow`) და შეკუმშვა (`flex-shrink`) იწყებს ათვლას `0`-დან. ცარიელ დივებს, თუ ჩვენ არ მივანიჭებთ, არ აქვთ სიმაღლე (height), ამიტომ ჩვენმა ფლექს აითემებმა რომ შეავსონ მათი კონტეინერის სიმაღლე, მათ არ უნდა ჰქონდეთ სიმაღლე გაწერილი.

ზედა მაგალითის გამოსწორება შეიძლება `flex: 1 1 auto`-ს მინიჭებით. ასევე ამის მოგვარება შეგვეძლო სიმაღლის მინიჭებით მათი მშობელი ელემენტისთვის, ამ შემთხვევაში `.flex-container`-ისთვის, ან უბრალოდ `flex-grow: 1` გამოგვეყენებინა.

კიდევ ერთი გასათვალისწინებელი დეტალია ის, რომ როდესაც გვაქვს `flex-direction: column`, `flex-basis` მიმართავს `height`-ს და არა `width`-ს.

როდესაც ვიყენებთ `flex-direction: row`-ს, ჰორიზონტალურად ყველაფერი "კარგად" ლაგდება. ეს ხდება ზედმეტი სტილების შეცვლის გარეშე, რადგან block ელემენტები ითვისებენ მშობელი ელემენტის სრულ სიგანეს (width). `flex-direction: column`-ზე შეცვლისას ცოტათი იხლართება, რადგან block ელემენტები იღებენ მათში განთავსებული კონტენტის ზომას, მაგრამ ამ შემთხვევაში *კონტენტი არ გვაქვს*.

## დამატებითი რესურსები

- [ეს კონსპექტი](https://flexbox.malven.co/) დაგეხმარებათ ზუსტად და სრულად გაიაზროთ flex-ის ყველა სტილი და მნიშვნელობა.
