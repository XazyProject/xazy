# კასკადი

## შესავალი

წინა გაკვეთილში, ჩვენ გავიარეთ ელემენტარული CSS სინტაქსი და სელექტორები. ახლა დროა გავაერთიანოთ ეს ცოდნა.

## გაკვეთილის მიმოხილვა

- რას აკეთებს კასკადი.
- CSS სელქტორების გაერთიანება.
- რა გავლენა აქვს "მემკვიდრეობით" სელექტორებს ზოგიერთ სტილზე.

## CSS-ს კასკადი

ზოგჯერ ისეთი სტილები გვაქვს დაწერილი, რომლებიც ერთმანეთთან უთანხმოებაში მოდის და ვიღებთ მოულოდნელ შედეგებს. "მე მინდოდა ეს პარაგრაფი ლურჯი ყოფილიყო, მაგრამ რატომ არის ეს წითელი სხვა პარაგრაფების მსგავსად?" როგორი გასაკვირიც არ უნდა იყოს, უნდა გავითვალისწინოთ რომ CSS არ აკეთებს რასაც უნდა თავის სურვილის მიხედვით და არ მიდის ჩვენს წინააღმდეგ. CSS მხოლოდ იმას აკეთებს, რასაც ჩვენ დავავალებთ. ერთადერთი გამონაკლისია მაშინ, როდესაც თავად ბრაუზერი ადებს სტილებს თავისით. ეს "საწყისი" სტილები განსხვავებულია სხვადასხვა ბრაუზერში, ზოგს მეტი დაშორება აქვს წინასწარ გაწერილი, ზოგს ნაკლები, მიუხედავად იმისა, რომ ჩვენ არაფერი არ გაგვიწერია. ამ ბრაუზერის სტილების გაუქმებას მოგვიანებით, უფრო სიღრმისეულ CSS ნაწილში რომ გადავალთ, მაშინ ვისწავლით.

ამიტომ თუ თქვენ CSS-ს გაუთვალისწინებელ "საქციელს" გადაეყრებით ან ბრაუზერის სტილების ბრალია, ან კარგად არ ვიცით როგორ მუშაობს სტილები, ან არ ვიცით ეს კასკადა.

კასკადი არის ის, რაც საზღვრავს, რომელი წესები დაედოს HTML ელემენტებს. არის სხვადასხვა ფაქტორები, რის მიხედვითაც განსაზღვრავს კასკადი ამას. ახლა განვიხილავთ სამ ფაქტორს, რომელიც დაგვეხმარება გაგებაში.

### სპეციფიურობა

CSS დეკლარაციას, რომელიც უფრო სპეციფიურია, პრიორიტეტი მიენიჭება, ვიდრე ნაკლებად სპეციფიურ დეკლარაციებს. ხაზშიდა(inline CSS) სტილები, რომლებიც წინა ლექციაში ვისწავლეთ, არიან ყველაზე სპეციფიურები, რადგან კონკრეტულ, ერთ ელემენტს ვადებთ, ამიტომ პრიორიტეტი ყოველთვის მას მიენიჭება, თუ გვაქვს. სხვა სელექტორებიც არიან სპეციფიურები, მაგრამ ახლა, მხოლოდ განვლილ სელექტორებს განვიხილავთ:

1. ID სელექტორები (ყველაზე სპეციფიური სელექტორი)
2. კლასის სელექტორი
3. ტიპის სელექტორი

სპეციფიურობა მხოლოდ მაშინ არის გასათვალისწინებელი, როდესაც რამდენიმე, ერთმანეთთან კონფლიქტური დეკლარაცია გვაქვს და გვსურს გადავწყვიტოთ ეს პრობლემა. ID სელექტორი ყოველთვის აჯობებს ნებისმიერ კლასის სელექტორს, ხოლო კლასის სელექტორი ყოველთვის აჯობებს ტიპის სელექტორს და ტიპის სელექტორი ყოველთვის აჯობებს სხვა, ნაკლებად სპეციფიურ სელექტორებს. ეს იმას ნიშნავს, რომ, თუ გვაქვს ტიპის სელექტორი, ანუ `p { color:red; }` და ყველა პარაგრაფს აქვს ტექსტის ფერი წითელი, თუ რომელიმე პარაგრაფს დავადებთ ჩვენს მიერ შექმნილ კლასს, რომელიც ტექსტის ფერს მწვანეს ხდის, ამ პარაგრაფს ექნება მწვანე ფერი, რადგან კლასის სელექტორი უფრო პრიორიტეტულია ვიდრე ტიპის სელექტორი. 


ახლა განვიხილოთ მაგალითები, რათა ვიზუალურად უფრო ადვილი წარმოსადგენი იყოს.

```html
<!-- index.html -->

<div class="mtavari">
  <div class="list seqcia">წითელი ტექსტი</div>
</div>
```

```css
/* styles.css */

/* სტილი 1 */
.seqcia {
  color: blue;
}

/* სტილი 2 */
.mtavari .list {
  color: red;
}
```

ამ მაგალითში ორივე სტილი იყენებს მხოლოდ კლასის სელქტორს, მაგრამ მეორე სტილი უფრო სპეციფიურია, რადგან ის იყენებს უფრო მეტ კლასის სელექტორს, ამიტომ `color: red` დეკლარაცია დაედება.

ახლა ცოტათი შევცვალოთ ეს კოდი:

```html
<!-- index.html -->

<div class="mtavari">
  <div class="list" id="seqcia">ლურჯი ტექსტი</div>
</div>
```

```css
/* styles.css */

/* სტილი 1 */
#seqcia {
  color: blue;
}

/* სტილი 2 */
.mtavari .list {
  color: red;
}
```

ამ მაგალითში, მიუხედავად იმისა, რომ მეორე სტილს აქვს უფრო მეტი კლას სელექტორი, ვიდრე ID სელექტორს, პირველი სტილი უფრო სპეციფიკურია, რადგან ID ამარცხებს კლასს. ამ შემთხვევაში დაედება `color: blue`.

და ცოტათი უფრო ჩახლართული:

```html
<!-- index.html -->

<div class="mtavari">
  <div class="list" id="seqcia">წითელი ტექსტი ყვითელ ფონზე</div>
</div>
```

```css
/* სტილი 1 */
#seqcia {
  background-color: yellow;
  color: blue;
}

/* სტილი 2 */
.mtavari #seqcia {
 color: red;
}
```

ამ მაგალითსი, პირველი სტილი იყენებს ID სელექტორს, ხოლო მეორე კლასისა და ID სელექტორის ნაზავია. ანუ, არცერთი სტილი არ არის უფრო სპეციფიური სელექტორი ერთმანეთზე. ამ შემთხვევაში კასკადი ამოწმებს თითოეული სელექტორის ტიპის რაოდენობას. ორივე სტილს აქვს მხოლოდ ერთი ID სელექტორი, მაგრამ მეორე სტილს აქვს კლასის სელექტორიც დამატებით ID სელექტორთა, ანუ მეორე სტილი უფრო კონკრეტულია!

ამ კოდის შემთხვევაში კონფლიქტი მხოლოდ ფერზეა, ანუ დაედება `color: red`, რადგან ამან კონფლიქტში გაიმარჯვა, ხოლო `background-color: yellow` მაინც დაედება, რადგან არაფერთან არ მოდის კონფლიქტში.

```css
/* სტილი 1 */
.class.meore-class {
  font-size: 12px;
}

/* სტილი 2 */
.class .meore-class {
  font-size: 24px;
}
```
აქ ორივე, პირველ და მეორე სტილს, აქვს იგივე სპეციფიურობა. პირველი სტილი იყენებს ჯაჭვურ სელექტორს (სფეისი არაა კლასებს შორის) და მეორე სტილი იყენებს "შთამომავლობის" კომბინატორს (Descendant combinator) (სპეისი კლასებს შორის). 

```css
/* სტილი 1 */
.class.meore-class {
  font-size: 12px;
}

/* სტილი 2 */
.class > .meore-class {
  font-size: 24px;
}
```

ეს მაგალითი იგივეა, რაც ზევითა. მიუხედავად იმისა, რომ მეორე სტილი იყენებს შვილ კომბინატორს (`>`), ეს არ ცვლის პრიორიტეტს. ორივესტილს აქვს ორი კლასი, ანუ ორივეს აქვს თანაბარი პრიორიტეტი.

```css
/* სტილი 1 */
* {
  color: black;
}

/* სტილი 2 */
h1 {
  color: orange;
}
```

ამ მაგალითში, მეორე სტილს უფრო მაღალი პრიორიტეტი ექნება და `orange` მნიშვნელობა დაედება. მეორე სტილი იყენებს ტიპის სელექტორს, რომელსაც აქვს ყველაზე დაბალი პრიორიტეტი სელექტორებში, მაგრამ პირველ სტილში ვიყენებთ უნივერსალურ სელექტორს (`*`), რომელსაც საერთოდ არ აქვს პრიორიტეტი.

### მემკვიდრეობა

როდესაც HTML ელემენტს ვსტილავთ, ზოგიერთი CSS სტილი გადაეცემა მის მემკვიდრეებსაც, ანუ შიგნით მყოფ ელემენტებს, მიუხედავად იმისა, გავუწერეთ თუ არა რაიმე სტილი ამ ელემენტებს. მსგავსი CSS სტილები (`color`, `font-size`, `font-family` და ა.შ.) გადაეცემათ სხვა შიგნით მყოფ ელემენტებს, მაგრამ უმეტესი სტილი ასე არ მუშაობს.

გამონაკლისია, როდესაც პირდაპირ ვნიშნავთ ელემენტს, ეს ყოველთვის ამარცხებს "მემკვიდრეობას".

```html
<!-- index.html -->

<div id="mshobeli">
  <div class="shvili"></div>
</div>
```

```css
/* styles.css */

#mshobeli {
  color: red;
}

.shvili {
  color: blue;
}
```

მიუხედავად იმისა, რომ `parent` ელემენტს აქვს პრიორიტეტი, რადგან ID-ა, `shvili` ელემენტს ექნება `color: blue` სტილი, რადგან ეს დეკლარაცია პირდაპირ ამ ელემენტს ეხება, ხოლო `color: red` მშობლისგან გადადის.

### თანმიმდევრული წყობა (Rule order)

წარმოიდგინეთ გაქვთ ბევრი უთანხმოება CSS-ში, ყველა კოდი ერთმანეთს აწერს ზევიდან თავიანთ სტილს და მოდიან კონფლიქტში. ამ დროს რას გადაწყვიტავს კასკადი, რომელი სტილი დაადოს?

უმარტივესია. ვინც ბოლო ის გამარჯვებული.

```css
/* styles.css */

.alert {
  color: red;
}

.warning {
  color: yellow;
}
```

გვაქვს ელემენტი, რომელსაც აქვს ორივე კლასი, `alert` და `warning`, კასკადი გაივლის ყველა სხვა ფაქტორს, მემკვიდრეობას (აქ არ გვაქვს), პრიორიტეტს (არც აქ არის პრიორიტეტი, ორივე ერთნაირად პრიორიტეტულია) და ბოლოს დაადებს იმას, რომელიც ყველაზე ბოლოს დადეკლარირდა ჩვენს ფაილში, ამ შემთხვევაში `.warning` კლასი უფრო ქვევით წერია `styles.css` ფაილში, ვიდრე `.alert`, ამიტომ დაედება ბოლო, ანუ `.warning`.

ტიპის სელექტორზე იქნება შემდეგნაირად:

```css
/* styles.css */

h1 {
  color: red;
}

h1 {
  color: blue;
}
```

ეს შემთხვევაც იგივენაირია, კოდში ორჯერ არის h1 გასტილული, ორივე თანაბრად პრიორიტეტულია, ამიტომ დაედება ის სტილი, რომელიც ამ დოკუმენტში უკანასკნელია, ანუ იქნება `color: blue;`.

## დავალება

<div className="homework">
1. გადადით [ჩვენს CSS დავალებების რეპოზიტორში](https://github.com/XazyProject/css-davalebebi) და შედით `fundamentalebi` ფოლდერში, გადაიკითხეთ README ფაილი და შეასრულეთ ბოლო დავალება:
    - `06-kaskadis-gasworeba`

    შენიშვნა: თითოეული ამოცანის ამოხსნა შეგიძლიათ იხილოთ `amoxsna` ფოლდერში.

2. გაიხსენეთ რეცეპტების საიტი, რომელიც თქვენ გააკეთეთ HTML-ში სავარჯიშოთ. გახსენით ეს პროექტი და გავსტილოთ.

    - გასტილვა მთლიანად თქვენს გემოვნებაზეა დამოკიდებული, მაგრამ თქვენ უნდა გამოიყენოთ external CSS მეთოდი, ანუ CSS-სთვის ცალკე ფაილი უნდა შექმნათ და დალინკოთ HTML ფაილში. ასევე უნდა გამოიყენოთ სტილები, რომლებიც ჩვენ ვისწავლეთ (`color`, `background-color`, `font-size` და ა.შ.). დაუთმეთ დრო სხვადასხვა სტილებით "თამაშს", რათა ზუსტად მიხვდეთ რომელი რას აკეთბს. თავიდან არ გაამახვილოთ ყურადღება, რომ კარგად გამოიყურებოდეს.
    - გადაავლეთ თვალი [უსაფრთხო ფონტების სიას](https://www.w3schools.com/cssref/css_websafe_fonts.php), რომლებიც ძირითადად ყველა კომპიუტერშია დაინსტალირებული და ყველასთან გახსნის ამ ფონტს.

 </div>

